#ifndef __IPCTOOLS_LOGGER_H__
#define __IPCTOOLS_LOGGER_H__

#include "allocator_shm.h"
#include "shared_queue.h"

#define LOGGER_MAX_MESSAGE_SIZE (256)

typedef ipt_shared_queue_node_t ipt_logger_node_t;
typedef struct ipt_logger_t ipt_logger_t;
typedef struct ipt_logger_message_t ipt_logger_message_t;
typedef enum ipt_log_category_mask_t ipt_log_category_mask_t;
typedef enum ipt_log_level_mask_t ipt_log_level_mask_t;

enum ipt_log_category_mask_t
{
	/* Modules */
	IPT_MODULE_FAULT   = 1<<0,
	IPT_MODULE_MODULE  = 1<<1,
	IPT_MODULE_ALL     = 0xffffffff,

	/* Processes */
	IPT_PROCESS_PROCESS_ONE    = 1<<4
};

enum ipt_log_level_mask_t
{
	IPT_LEVEL_EMERG    = 1<<0,
	IPT_LEVEL_ALERT    = 1<<1,
	IPT_LEVEL_CRIT     = 1<<2,
	IPT_LEVEL_ERROR    = 1<<3,
	IPT_LEVEL_WARNING  = 1<<4,
	IPT_LEVEL_NOTICE   = 1<<5,
	IPT_LEVEL_INFO     = 1<<6,
	IPT_LEVEL_DEBUG    = 1<<7,
	IPT_LEVEL_ALL      = 0xffffffff 
};

/**
 * @struct ipt_logger_message_t
 *
 * @brief This wrapper for messages used by logging system.
 *
 * Each message sent to the logging subystem will be wrapped
 * with standard informaton.
 *
 */
struct ipt_logger_message_t
{
   /**
    *  Node linkage for instrusive shared list
    * /
   ipt_logger_node_t node;

   /**
    * Category mask. 
    *
    * This does not map to syslog in RFC3164
    * and are defined internally.
    *
    * If a message is sent to a remote syslog server
    * it will be mapped to Facility 2 (user messages)
    * defined in 
    */
   ipt_log_category_mask_t cmask;

   /**
    * Level mask.
    *
    * This maps directly to syslog severity level defined
    * int RFC 3164.
    */
   ipt_log_level_mask_t lmask;

   /**
    * Name of process that originated message
    */
   char originator[32];

   /**
    * Time at which the message was generated.
    *
    * where the format is * [RFC 3164]:[milliseconds]
    *
    * milliseconds is added for local logging, but stripped when
    * sending to remote syslog server.
    *
    */
   char time[32];

   /**
    * Message generated by the process.
    */
   char message[LOGGER_MAX_MESSAGE_SIZE];
};

struct ipt_logger_t
{

	void (*enqueue)(ipt_logger_t *this, ipt_log_category_mask_t category_mask, ipt_log_level_mask_t level_mask, const char *originator, const char *fmt, ...);

	ipt_logger_message_t * (*dequeue)(ipt_logger_t *this);

	ipt_logger_message_t * (*dequeue_timed)(ipt_logger_t *this, ipt_time_value_t *tv);

   	ipt_allocator_t* (*get_allocator)(ipt_logger_t *this);

	int (*is_category_set)(ipt_logger_t *this, enum ipt_log_category_mask_t category);

	int (*is_level_set)(ipt_logger_t *this, enum ipt_log_level_mask_t level);

	ipt_log_category_mask_t (*get_category_mask)(ipt_logger_t *this);

	ipt_log_level_mask_t (*get_level_mask)(ipt_logger_t *this);

	void (*set_category)(ipt_logger_t *this, enum ipt_log_category_mask_t category);

	void (*set_level)(ipt_logger_t *this, enum ipt_log_level_mask_t level);

	void (*unset_category)(ipt_logger_t *this, enum ipt_log_category_mask_t category);

	void (*unset_level)(ipt_logger_t *this, enum ipt_log_level_mask_t level);

	int (*get_fd)(ipt_logger_t *this);

	void (*free)(ipt_logger_t *this, void *);

	int (*syslog_priority)(ipt_logger_t *this, ipt_logger_message_t *msg);

};

ipt_logger_t *ipt_logger_create(const char *name, ipt_allocator_t *alloc_ptr);

ipt_logger_t * ipt_logger_attach(const char *name, ipt_allocator_t *alloc_ptr);

void ipt_logger_for_each(ipt_logger_t *this, void (*func)(const ipt_logger_node_t * const, void *), void *in_ptr);

// Simple function that wraps logger and uses stdout if logger is NULL
void ipt_log_message(ipt_logger_t* logger, int category, int level, char* msg, ...);

#endif
