#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <stdio.h>
#include <semaphore.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>


#include "allocator_shm.h"
#include "offset_ptr.h"
#include  <sys/file.h>

struct __node__
{
	ipt_op_t prev;
	ipt_op_t next;
	unsigned int size;
};

struct reg_obj
{
	struct __node__ node;	
	ipt_op_t item;	
	ipt_op_t name;
};

struct shared_data
{
	/* Free List head & tail */
	ipt_op_t free_list_head;
	ipt_op_t free_list_tail;

	ipt_op_t ro_list_head;
	ipt_op_t ro_list_tail;

	unsigned int bytes_allocated;
	unsigned int num_blocks_allocated;
	unsigned int size;

	char __null__;
};

typedef struct private_allocator_t private_allocator_t;

struct private_allocator_t
{
	ipt_allocator_t public;

	struct shared_data *sd_ptr;

};

static void print_registered_object(struct reg_obj *ptr)
{
                printf("Registered Object[name:%s]\n",ipt_op_drf(&ptr->name));
}
static void print_free_block(struct __node__ *ptr)
{
		printf("Block[begin:%p, end:%p, prev:%p, next:%p size:%d]\n",ptr, 
			ipt_add_offset((char *)ptr,ptr->size), 
			ipt_op_drf(&ptr->prev),
			ipt_op_drf(&ptr->next),
			ptr->size);
}

static void walk_ro_list(private_allocator_t *this, void (*fnc)(struct reg_obj *) )
{
	struct __node__ *cur_ptr;

	for ( 	cur_ptr = ( struct __node__ *) ipt_op_drf(&this->sd_ptr->ro_list_head);
		cur_ptr != (struct __node__ *) &this->sd_ptr->__null__;
		cur_ptr = ( struct __node__ *) ipt_op_drf(&cur_ptr->next) )
	{
		(*fnc)((struct reg_obj *) cur_ptr);
	}
}

static void walk_free_list(private_allocator_t *this, void (*fnc)(struct __node__ *ptr))
{
	struct __node__ *cur_ptr;

	for ( 	cur_ptr = ( struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_head);
		cur_ptr != (struct __node__ *) &this->sd_ptr->__null__; 
		cur_ptr = ( struct __node__ *) ipt_op_drf(&cur_ptr->next) )
	{
		(*fnc)(cur_ptr);
	}
}

static unsigned int ipt_allocator_overhead(void)
{
	return sizeof(private_allocator_t) + sizeof(struct __node__);
}

static void * 
private_malloc(private_allocator_t *this, unsigned int size)
{
	struct __node__ *cur_ptr;

	/* Walked the free list and find a chunck big enough */
	for (   cur_ptr  = (struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_head); 
		cur_ptr != (struct __node__ *) &this->sd_ptr->__null__; 
		cur_ptr  = (struct __node__ *)ipt_op_drf(&cur_ptr->next) )
  {
		if ( cur_ptr->size < sizeof(struct __node__) + size ) continue;

		/* Split the block by pulling chunk off bottom */	
		struct __node__ *n_ptr = (struct __node__ *) (ipt_add_offset((char *)cur_ptr, cur_ptr->size - size - sizeof( struct __node__ )));

		this->sd_ptr->bytes_allocated += size;

		this->sd_ptr->num_blocks_allocated++;

		cur_ptr->size -= (sizeof( struct __node__) + size);

		n_ptr->size = sizeof(struct __node__) + size;

      		/* Special Case where size matches exactly */
		if ( cur_ptr->size ==  sizeof(struct __node__) + size )
		{

			/*      addr a      <     addr b     <  addr c    
			 *  ---------------- ---------------- ----------------
			 * |                |                |                |
			 * |      next ---> |      next ---> |      next ---> |
			 * | <--- prev      | <--- prev      | <--- prev      |
			 * |                |                |                |
			 *  ---------------- ---------------- ----------------
			 *                         ^                 
			 *                      (cur_ptr)          
			 */
         if ( ipt_op_drf(&cur_ptr->prev) != &this->sd_ptr->__null__ )
         {
            ipt_op_set(&((struct __node__ *)ipt_op_drf(&cur_ptr->prev))->next, ipt_op_drf(&cur_ptr->next));
         }

         if ( ipt_op_drf(&cur_ptr->next) != &this->sd_ptr->__null__)
         {
            ipt_op_set(&((struct __node__ *)ipt_op_drf(&cur_ptr->next))->prev, ipt_op_drf(&cur_ptr->prev)); 
         }

			/* Update head and tail pointers  */
			if ( (struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_head) == cur_ptr )
			{
				ipt_op_set(&this->sd_ptr->free_list_head, ipt_op_drf(&cur_ptr->prev));
			}

			if ( (struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_tail) == cur_ptr )
			{
				ipt_op_set(&this->sd_ptr->free_list_tail, ipt_op_drf(&cur_ptr->next));
			}

		}
		return (void *)ipt_add_offset((char *)n_ptr, sizeof(struct __node__));
	}

	return NULL;
}
static void
private_free(private_allocator_t *this, void *ptr)
{
	struct __node__ * n_ptr = ( struct __node__ *) ipt_sub_offset( ( char *)ptr,sizeof(struct __node__) );
	struct __node__ *cur_ptr;


	for ( cur_ptr = ( struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_head);
         cur_ptr !=  (struct __node__ *)&this->sd_ptr->__null__;
         cur_ptr = ( struct __node__ *) ipt_op_drf(&cur_ptr->next) )
   {

		/* Check to skip block */	
		if ( ipt_op_drf(&cur_ptr->next)  != &this->sd_ptr->__null__  &&  cur_ptr  < n_ptr) 
		{
			continue;
		}

		if ( ipt_op_drf(&cur_ptr->prev) == &this->sd_ptr->__null__ &&  n_ptr <  cur_ptr )
		{
			/*      addr a      <     add b    
			 *  ---------------- ---------------
			 * |   (free node)  |                |
			 * |      next ---> |      next ---> |     
			 * | <--- prev      | <--- prev      | 
			 * |                |                |
			 *  ---------------- ----------------| 
			 *         ^                 ^
			 *      (n_ptr)          (cur_ptr)
			 *                        (head)
			 */
			ipt_op_set(&n_ptr->next,cur_ptr);
			ipt_op_set(&n_ptr->prev, &this->sd_ptr->__null__);
			ipt_op_set(&cur_ptr->prev,n_ptr);
			ipt_op_set(&this->sd_ptr->free_list_head, n_ptr);
			break;
		}	
		else if ( ipt_op_drf(&cur_ptr->next)  == &this->sd_ptr->__null__ &&  cur_ptr  < n_ptr)
		{
			/*      addr a      <     add b    
			 *  ---------------- ---------------
			 * |                |                |
			 * |      next ---> |      next ---> |     
			 * | <--- prev      | <--- prev      | 
			 * |                |                |
			 *  ---------------- ----------------| 
			 *         ^                 ^
			 *      (cur_ptr)         (n_ptr)
			 *       (tail)
			 */
			ipt_op_set(&n_ptr->prev,cur_ptr);
			ipt_op_set(&n_ptr->next, &this->sd_ptr->__null__);
			ipt_op_set(&cur_ptr->next, n_ptr);
			ipt_op_set(&this->sd_ptr->free_list_tail, n_ptr);
			break;
		}
		else
		{
			/*      addr a      <     addr b     <  addr c    
			 *  ---------------- ---------------- ----------------
			 * |                |   (free node)  |                |
			 * |      next ---> |      next ---> |      next ---> |
			 * | <--- prev      | <--- prev      | <--- prev      |
			 * |                |                |                |
			 *  ---------------- ---------------- ----------------
			 *                         ^                 ^
			 *                      (n_ptr)          (cur_ptr)
			 */
			ipt_op_set( &((struct __node__ *)ipt_op_drf(&cur_ptr->prev))->next, n_ptr);
			ipt_op_set(&n_ptr->next,cur_ptr);
			ipt_op_set(&n_ptr->prev, (void *)ipt_op_drf(&cur_ptr->prev));
			ipt_op_set(&cur_ptr->prev,n_ptr);
         break;
		}
   }

	/* Handle the empty list scenario */
	if ( ipt_op_drf(&this->sd_ptr->free_list_head)  == &this->sd_ptr->__null__ )
	{
		ipt_op_set(&n_ptr->prev, &this->sd_ptr->__null__);
		ipt_op_set(&n_ptr->next, &this->sd_ptr->__null__);
		ipt_op_set(&this->sd_ptr->free_list_head, n_ptr);
		ipt_op_set(&this->sd_ptr->free_list_tail, n_ptr);
	}

	this->sd_ptr->num_blocks_allocated--;

	this->sd_ptr->bytes_allocated -=  (n_ptr->size - sizeof(struct __node__));

	return;	
}
static int
register_object(private_allocator_t *this, const char *name, void *ptr)
{

	struct __node__  *n_ptr = (struct __node__ * ) this->public.malloc(&this->public,sizeof(struct reg_obj));

	char *name_ptr = (char * ) this->public.malloc(&this->public,strlen(name) + 1);
	
	strcpy(name_ptr,name);

	ipt_op_set(&n_ptr->prev, ipt_op_drf(&this->sd_ptr->ro_list_tail));
	ipt_op_set(&n_ptr->next,&this->sd_ptr->__null__);

	ipt_op_set(&(( struct reg_obj *)n_ptr)->item, ptr);
	ipt_op_set(&(( struct reg_obj *)n_ptr)->name, (void *)name_ptr);

	if ( ipt_op_drf(&this->sd_ptr->ro_list_tail) != &this->sd_ptr->__null__)
	{
		ipt_op_set( &((struct __node__ *)ipt_op_drf(&this->sd_ptr->ro_list_tail))->next,n_ptr);
	}

	if ( ipt_op_drf(&this->sd_ptr->ro_list_head) == &this->sd_ptr->__null__)
	{
		ipt_op_set(&this->sd_ptr->ro_list_head,n_ptr);
	}

	ipt_op_set(&this->sd_ptr->ro_list_tail,n_ptr);

	return 0;
	
}

static int
deregister_object(private_allocator_t *this, const char *name)
{
	struct __node__ *cur_ptr;

        for (   cur_ptr = ( struct __node__ *) ipt_op_drf(&this->sd_ptr->ro_list_head);
                cur_ptr != ( struct __node__ *) &this->sd_ptr->__null__;
                cur_ptr = ( struct __node__ *) ipt_op_drf(&cur_ptr->next) )
        {
                printf("Registered Object[item:%p, name:%s]\n",ipt_op_drf( &((struct reg_obj *)cur_ptr)->item ), ipt_op_drf( &((struct reg_obj *)cur_ptr)->name));
        }
}
static void * 
find_registered_object(private_allocator_t *this, const char *name)
{
	struct __node__ *cur_ptr;

        for (   cur_ptr = ( struct __node__ *) ipt_op_drf(&this->sd_ptr->ro_list_head);
                cur_ptr !=  (struct __node__ *) &this->sd_ptr->__null__;
                cur_ptr = ( struct __node__ *) ipt_op_drf(&cur_ptr->next) )
        {
		struct reg_obj *r_ptr = (struct reg_obj *)cur_ptr;
		if ( !strcmp(name, (char *) ipt_op_drf( &((struct reg_obj *)cur_ptr)->name) ) )
		{
			return (void *) ipt_op_drf( & (( struct reg_obj *)cur_ptr)->item);
		}
        }

	return NULL;
}

static void
dump_stats(private_allocator_t *this)
{
	struct __node__ *cur_ptr;
	unsigned int overhead;

	overhead = sizeof(struct __node__) * this->sd_ptr->num_blocks_allocated + sizeof( private_allocator_t);

	fprintf(stdout,"Allocator[\n");
	fprintf(stdout,"\tbytes allocated = %d\n",this->sd_ptr->bytes_allocated);
	fprintf(stdout,"\tbytes remaining = %d\n",this->sd_ptr->size - this->sd_ptr->bytes_allocated);	
	fprintf(stdout,"\toverhead/allocation = %d bytes\n",sizeof(struct __node__));
	fprintf(stdout,"\toverhead/Allocator  = %d bytes\n",sizeof(private_allocator_t));
	fprintf(stdout,"\tefficiency          = %2.2f %\n", (1 - overhead*1.0/this->sd_ptr->size)*100);

	fprintf(stdout,"Blocks on Free List ... \n");
	walk_free_list(this, print_free_block);
	fprintf(stdout,"Blocks finished\n");

	fprintf(stdout,"Registered Objects ... \n");
	walk_ro_list(this, print_registered_object);
	fprintf(stdout,"Registered Objects finished\n");

	return;	
}
static unsigned int
get_size(private_allocator_t *this)
{
	return this->sd_ptr->size + ipt_allocator_overhead();
}

static int lock(private_allocator_t *this)
{
	return 0;
}

static int unlock(private_allocator_t *this)
{
	return 0;
}

static void
destroy(ipt_allocator_t *this)
{
	if ( this != NULL ) shmdt( ((private_allocator_t * ) this)->sd_ptr );

	return;
}
ipt_allocator_t * ipt_allocator_malloc_create(unsigned int size)
{
int shmid;
void *base_address;

      	//if ( (base_address = shmat(shmid,(void *)0x40000000, 0)) == (void *) -1)
      	if ( (base_address = malloc(size) ) == NULL)

       	{
               	return NULL;
       	}

	private_allocator_t *this = malloc(sizeof(private_allocator_t));

	if ( this == NULL )
	{
		return NULL;
	}

	this->sd_ptr = (struct shared_data *) base_address;

	memset((char*)this->sd_ptr, 0, size + ipt_allocator_overhead());

        /* Initialize data */
        this->sd_ptr->size = size;

        /* Assign public interface */
        this->public.malloc = (void * (*)(ipt_allocator_t *, unsigned int) ) private_malloc;
        this->public.free   = (void (*)(ipt_allocator_t *, void *) ) private_free;
        this->public.dump_stats = (void (*)(ipt_allocator_t *) ) dump_stats;
        this->public.register_object = (int (*)(ipt_allocator_t *, const char *name, void *) ) register_object;
        this->public.find_registered_object = (void *(*)(ipt_allocator_t *, const char *) ) find_registered_object;
        this->public.deregister_object = (int (*)(ipt_allocator_t *, const char *) ) deregister_object;
        this->public.get_size = (unsigned int (*)(ipt_allocator_t *) ) get_size;
	this->public.destroy = (void (*)(ipt_allocator_t*) ) destroy;

        /* Start the free list after the private_allocator_t */
        ipt_op_set(&this->sd_ptr->free_list_head, ipt_add_offset((char *)this->sd_ptr,sizeof(struct shared_data)));

        /* Start the free list after the private__allocator_t */
        ipt_op_set(&this->sd_ptr->free_list_tail, ipt_add_offset((char *)this->sd_ptr,sizeof(struct shared_data)));

 	/* Set the node structure */
        struct __node__ *n_ptr  = (struct __node__ *) ipt_op_drf(&this->sd_ptr->free_list_head);
    
        /* Initialize the node structure */
        ipt_op_set(&n_ptr->prev, &this->sd_ptr->__null__);
        ipt_op_set(&n_ptr->next, &this->sd_ptr->__null__);

        n_ptr->size = ipt_allocator_overhead() + size - sizeof(private_allocator_t);

	/* Set the registered object list to null */
	ipt_op_set(&this->sd_ptr->ro_list_head,&this->sd_ptr->__null__);
	ipt_op_set(&this->sd_ptr->ro_list_tail,&this->sd_ptr->__null__);


	return (ipt_allocator_t *) this;
}

ipt_allocator_t * ipt_allocator_malloc_attach(void *base_address)
{
int shmid;

	
	private_allocator_t *this = malloc(sizeof(private_allocator_t));

	if ( this == NULL )
	{
		return NULL;
	}

	this->sd_ptr = (struct shared_data *) base_address;
	
        /* Assign public interface */
        this->public.malloc = (void * (*)(ipt_allocator_t *, unsigned int) ) private_malloc;
        this->public.free   = (void (*)(ipt_allocator_t *, void *) ) private_free;
        this->public.dump_stats = (void (*)(ipt_allocator_t *) ) dump_stats;
        this->public.register_object = (int (*)(ipt_allocator_t *, const char *name, void *) ) register_object;
        this->public.find_registered_object = (void *(*)(ipt_allocator_t *, const char *) ) find_registered_object;
        this->public.deregister_object = (int (*)(ipt_allocator_t *, const char *) ) deregister_object;
        this->public.get_size = (unsigned int (*)(ipt_allocator_t *) ) get_size;
	this->public.destroy = (void (*)(ipt_allocator_t*) ) destroy;

	return (ipt_allocator_t *) this;
}
